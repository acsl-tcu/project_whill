function [waypoint, waypoint_segments, room_sequence, door_info] = generateMultiRoomPath(initial_position, goal_position, robot_width, robot_length, safety_margin)
    % generateMultiRoomPath - Generate multi-room path using HybridPathPlanner
    %
    % This function calls the HybridPathPlanner which combines:
    %   - Dijkstra algorithm for room-level planning
    %   - A* algorithm for geometric path planning within rooms
    %
    % Inputs:
    %   initial_position - [x, y] starting position
    %   goal_position - [x, y] goal position
    %   robot_width - Width of robot in meters
    %   robot_length - Length of robot in meters
    %   safety_margin - Safety margin for obstacle clearance
    %
    % Outputs:
    %   waypoint - Nx2 array of first segment waypoints (for backward compatibility)
    %   waypoint_segments - Cell array of all waypoint segments
    %   room_sequence - Cell array of room IDs in path
    %   door_info - Struct with door_centers and door_exit_positions arrays
    %
    % Example:
    %   [wp, segments, rooms, doors] = generateMultiRoomPath([0,0], [30,10], 0.6, 1.0, 0.1);

    % Add path to MultiRoomNav directory
    multiroom_path = fullfile(fileparts(mfilename('fullpath')), '../../MultiRoomNav');
    addpath(multiroom_path);

    % Room database path
    room_database_path = fullfile(multiroom_path, 'room_database.json');

    % Check if room database exists
    if ~exist(room_database_path, 'file')
        error('Room database not found at: %s\nPlease ensure room_database.json exists in MultiRoomNav/', ...
              room_database_path);
    end

    try
        % Call HybridPathPlanner
        fprintf('Planning multi-room path using HybridPathPlanner...\n');
        fprintf('  Start: [%.2f, %.2f]\n', initial_position(1), initial_position(2));
        fprintf('  Goal: [%.2f, %.2f]\n', goal_position(1), goal_position(2));
        fprintf('  Robot: %.2fm x %.2fm, Safety margin: %.2fm\n', ...
                robot_width, robot_length, safety_margin);

        [waypoint_segments, room_sequence, total_distance] = HybridPathPlanner(...
            initial_position, goal_position, room_database_path, ...
            robot_width, robot_length, safety_margin);

        % Extract door information from room database for PhaseManager
        door_info = extractDoorInfo(room_database_path, room_sequence);

        fprintf('\n✓ Multi-room path planning successful!\n');
        fprintf('  Total distance: %.2f m\n', total_distance);
        fprintf('  Number of rooms: %d\n', length(room_sequence));
        fprintf('  Number of segments: %d\n', length(waypoint_segments));
        fprintf('  Number of doors: %d\n', length(room_sequence) - 1);

        % Return first segment as initial waypoints
        if isempty(waypoint_segments)
            error('No waypoint segments generated by HybridPathPlanner');
        end

        waypoint = waypoint_segments{1};

        % Display segment breakdown
        fprintf('\nSegment breakdown:\n');
        for i = 1:length(waypoint_segments)
            if i <= length(room_sequence)
                fprintf('  Segment %d (Room %s): %d waypoints\n', ...
                        i, room_sequence{i}, size(waypoint_segments{i}, 1));
            else
                fprintf('  Segment %d: %d waypoints\n', ...
                        i, size(waypoint_segments{i}, 1));
            end
        end
        fprintf('\n');

    catch ME
        fprintf('\n✗ ERROR: Multi-room path planning failed\n');
        fprintf('  Error: %s\n', ME.message);
        fprintf('  Stack: %s (line %d)\n', ME.stack(1).name, ME.stack(1).line);
        fprintf('\n→ Falling back to single-room A* pathfinding...\n\n');

        % Fallback to single-room A* (call the function from selectWaypointMethod)
        try
            [waypoint, ~, ~, ~, ~] = PathSetting_AStar(initial_position, goal_position, ...
                                                        robot_width, robot_length, safety_margin);
            fprintf('Fallback A* successful: Generated %d waypoints\n', size(waypoint, 1));
        catch ME2
            fprintf('Fallback A* also failed: %s\n', ME2.message);
            fprintf('Using original PathSetting as last resort...\n');
            [waypoint, ~, ~, ~, ~] = PathSetting_original;
        end

        % Return single segment (fallback case)
        waypoint_segments = {waypoint};
        room_sequence = {'Unknown'};
        door_info = struct();  % Empty door_info for fallback
    end
end

function door_info = extractDoorInfo(room_database_path, room_sequence)
    % Extract door centers and exit positions from room database
    % Based on the room sequence from Dijkstra
    %
    % Inputs:
    %   room_database_path - path to room_database.json
    %   room_sequence - cell array of room IDs {'A', 'B', 'D'}
    %
    % Outputs:
    %   door_info - struct with:
    %               - door_centers: Nx2 array of door center positions
    %               - door_exit_positions: Nx2 array of exit positions (from previous room)

    door_info = struct();
    door_info.door_centers = [];
    door_info.door_exit_positions = [];

    % Need at least 2 rooms to have doors
    if length(room_sequence) < 2
        return;
    end

    % Load room database JSON
    try
        json_text = fileread(room_database_path);
        db_data = jsondecode(json_text);
    catch ME
        warning('Failed to read room database: %s', ME.message);
        return;
    end

    % Extract doors for each transition in the sequence
    num_doors = length(room_sequence) - 1;
    door_centers = zeros(num_doors, 2);
    door_exit_positions = zeros(num_doors, 2);

    for i = 1:num_doors
        current_room = room_sequence{i};
        next_room = room_sequence{i+1};

        % Find the door connecting these two rooms
        door_found = false;
        for d = 1:length(db_data.doors)
            % db_data.doors is a cell array, use {} indexing
            door = db_data.doors{d};

            % Handle different MATLAB versions' jsondecode behavior
            % connects might be cell array or regular array
            if iscell(door.connects)
                connects_1 = door.connects{1};
                connects_2 = door.connects{2};
            else
                connects_1 = door.connects(1);
                connects_2 = door.connects(2);
            end

            % Check if this door connects the current and next room
            if (strcmp(connects_1, current_room) && strcmp(connects_2, next_room)) || ...
               (strcmp(connects_1, next_room) && strcmp(connects_2, current_room))

                % Found the door
                door_centers(i, :) = door.position;

                % CRITICAL: Exit position = entry point in NEXT room (not current room!)
                % This is where the wheelchair lands after passing through the door
                astar_field = sprintf('astar_goal_from_%s', next_room);
                if isfield(door, astar_field)
                    door_exit_positions(i, :) = door.(astar_field);
                else
                    % Fallback: use door center
                    door_exit_positions(i, :) = door.position;
                    warning('Door %s missing astar_goal_from_%s, using door center', door.id, next_room);
                end

                door_found = true;
                fprintf('  Door %d: %s (%s → %s) at [%.2f, %.2f], exit at [%.2f, %.2f]\n', ...
                    i, door.id, current_room, next_room, ...
                    door_centers(i, 1), door_centers(i, 2), ...
                    door_exit_positions(i, 1), door_exit_positions(i, 2));
                break;
            end
        end

        if ~door_found
            warning('No door found connecting room %s to %s', current_room, next_room);
            % Use zeros as placeholder
            door_centers(i, :) = [0, 0];
            door_exit_positions(i, :) = [0, 0];
        end
    end

    door_info.door_centers = door_centers;
    door_info.door_exit_positions = door_exit_positions;
end
