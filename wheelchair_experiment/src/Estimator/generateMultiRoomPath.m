function [waypoint, waypoint_segments, room_sequence, door_info] = generateMultiRoomPath(initial_position, goal_position, robot_width, robot_length, safety_margin, occupancyMap, roomGraph)
    % generateMultiRoomPath - Generate multi-room path using HybridPathPlanner
    %
    % This function calls the HybridPathPlanner which combines:
    %   - Dijkstra algorithm for room-level planning
    %   - A* algorithm for geometric path planning within rooms
    %
    % Inputs:
    %   initial_position - [x, y] starting position
    %   goal_position - [x, y] goal position
    %   robot_width - Width of robot in meters
    %   robot_length - Length of robot in meters
    %   safety_margin - Safety margin for obstacle clearance
    %   occupancyMap - Occupancy map object (passed from PhaseManager)
    %   roomGraph - RoomGraphWithDoorDistances object (passed from PhaseManager)
    %
    % Outputs:
    %   waypoint - Nx2 array of first segment waypoints (for backward compatibility)
    %   waypoint_segments - Cell array of all waypoint segments
    %   room_sequence - Cell array of room IDs in path
    %   door_info - Struct with door_centers and door_exit_positions arrays
    %
    % Example:
    %   [wp, segments, rooms, doors] = generateMultiRoomPath([0,0], [30,10], 0.6, 1.0, 0.1, map, graph);

    % Add path to MultiRoomNav directory
    multiroom_path = fullfile(fileparts(mfilename('fullpath')), '../../MultiRoomNav');
    addpath(multiroom_path);

    % Check if room graph is provided
    if nargin < 7 || isempty(roomGraph)
        error('Room graph not provided! Must be passed from PhaseManager.');
    end

    try
        % Call HybridPathPlanner with roomGraph
        fprintf('Planning multi-room path using HybridPathPlanner...\n');
        fprintf('  Start: [%.2f, %.2f]\n', initial_position(1), initial_position(2));
        fprintf('  Goal: [%.2f, %.2f]\n', goal_position(1), goal_position(2));
        fprintf('  Robot: %.2fm x %.2fm, Safety margin: %.2fm\n', ...
                robot_width, robot_length, safety_margin);

        [waypoint_segments, room_sequence, total_distance] = HybridPathPlanner(...
            initial_position, goal_position, roomGraph, ...
            robot_width, robot_length, safety_margin, occupancyMap);

        % Extract door information from room graph for PhaseManager
        door_info = extractDoorInfoFromGraph(roomGraph, room_sequence);

        % Return first segment as initial waypoints
        if isempty(waypoint_segments)
            error('No waypoint segments generated by HybridPathPlanner');
        end

        waypoint = waypoint_segments{1};

    catch ME
        fprintf('\n✗ ERROR: Multi-room path planning failed\n');
        fprintf('  Error: %s\n', ME.message);
        fprintf('  Stack: %s (line %d)\n', ME.stack(1).name, ME.stack(1).line);
        fprintf('\n→ Falling back to single-room A* pathfinding...\n\n');

        % Fallback to single-room A* (call the function from selectWaypointMethod)
        try
            [waypoint, ~, ~, ~, ~] = PathSetting_AStar(initial_position, goal_position, ...
                                                        robot_width, robot_length, safety_margin, occupancyMap);
            fprintf('Fallback A* successful: Generated %d waypoints\n', size(waypoint, 1));
        catch ME2
            fprintf('Fallback A* also failed: %s\n', ME2.message);
            fprintf('Using original PathSetting as last resort...\n');
            [waypoint, ~, ~, ~, ~] = PathSetting_original;
        end

        % Return single segment (fallback case)
        waypoint_segments = {waypoint};
        room_sequence = {'Unknown'};
        door_info = struct();  % Empty door_info for fallback
    end
end

function door_info = extractDoorInfoFromGraph(roomGraph, room_sequence)
    % Extract door centers and exit positions from room graph
    % Based on the room sequence from Dijkstra
    %
    % Inputs:
    %   roomGraph - RoomGraphWithDoorDistances object
    %   room_sequence - cell array of room IDs {'A', 'B', 'D'}
    %
    % Outputs:
    %   door_info - struct with:
    %               - door_centers: Nx2 array of door center positions
    %               - door_exit_positions: Nx2 array of exit positions (from previous room)

    door_info = struct();
    door_info.door_centers = [];
    door_info.door_exit_positions = [];

    % Need at least 2 rooms to have doors
    if length(room_sequence) < 2
        return;
    end

    % Extract doors for each transition in the sequence
    num_doors = length(room_sequence) - 1;
    door_centers = zeros(num_doors, 2);
    door_exit_positions = zeros(num_doors, 2);

    for i = 1:num_doors
        current_room_id = room_sequence{i};
        next_room_id = room_sequence{i+1};

        % Get room objects from graph
        current_room = roomGraph.getRoom(current_room_id);
        next_room = roomGraph.getRoom(next_room_id);

        % Get door from current room's perspective (for exit position)
        door_from_current = current_room.getDoorTo(next_room_id);

        % Get door from next room's perspective (for entry position)
        door_from_next = next_room.getDoorTo(current_room_id);

        if ~isempty(door_from_current) && ~isempty(door_from_next)
            % Door center is the actual door position
            door_centers(i, :) = door_from_current.door_center;

            % Exit position is the astar_goal in the NEXT room (where we land after crossing)
            door_exit_positions(i, :) = door_from_next.astar_goal;
        else
            warning('No door found connecting room %s to %s', current_room_id, next_room_id);
            % Use zeros as placeholder
            door_centers(i, :) = [0, 0];
            door_exit_positions(i, :) = [0, 0];
        end
    end

    door_info.door_centers = door_centers;
    door_info.door_exit_positions = door_exit_positions;
end
